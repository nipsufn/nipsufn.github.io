<!DOCTYPE html>
<html>

<head>
    <title>nipsufn's GPX track splitter</title>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <style>
        @font-face {
            font-family: Liberation Mono;
            src: url("../LiberationMono-Regular.woff2") format("woff2"), url("../LiberationMono-Regular.ttf") format("truetype");
        }

        html {
            height: 100vh;
        }

        body {
            color: #93a1a1;
            background-color: #002b36;
            font-family: Liberation Mono, SFMono-Regular, Consolas, Menlo, Courier, monospace;
            text-align: center;
            line-height: 1.19;
            height: 100%;
            display: flex;
            flex-direction: column;
            margin: 0px;
        }

        fieldset {
            flex-grow: 1;
            margin: 1em;
        }

        legend {
            margin: 0 auto;
            padding: 0 1em 0 1em;
        }
    </style>
</head>

<body>
    <fieldset>
        <legend>nipsufn's GPX track splitter</legend>
        <form>
            <label for="keepCommonPt">Make split tracks have a common point</label>
            <input id="keepCommonPt" type="checkbox" checked />
            <br />
            <label for="splitSegOnly">Split long segments inside existing tracks instead of creating new tracks</label>
            <input id="splitSegOnly" type="checkbox" />
            <br />
            <label for="splitAt">Make split tracks have a common point</label>
            <input id="splitAt" type="number" min="10" max="1000" value="500" required />
            <br />
            <label for="trkSuffix">Suffix appended to split tracks</label>
            <input id="trkSuffix" type="text" value="-part-" required />
            <br />
            <label for="fileSuffix">Suffix appended to filename</label>
            <input id="fileSuffix" type="text" value="split" required />
            <br />
            <label for="file">File</label>
            <input id="file" accept="application/gpx+xml,application/octet-stream,.gpx" type="file" />
        </form>
    </fieldset>
</body>
<script>
    function save(filename, data) {
        const blob = new Blob([data], { type: 'application/gpx+xml' });
        if (window.navigator.msSaveOrOpenBlob) {
            window.navigator.msSaveBlob(blob, filename);
        }
        else {
            const elem = window.document.createElement('a');
            elem.href = window.URL.createObjectURL(blob);
            elem.download = filename;
            document.body.appendChild(elem);
            elem.click();
            document.body.removeChild(elem);
        }
    }
    function clean(node) {
        for (var n = 0; n < node.childNodes.length; n++) {
            var child = node.childNodes[n];
            if
                (
                child.nodeType === 8
                ||
                (child.nodeType === 3 && !/\S/.test(child.nodeValue))
            ) {
                node.removeChild(child);
                n--;
            }
            else if (child.nodeType === 1) {
                clean(child);
            }
        }
    }
    function handleFileSelect(evt) {
        let file = evt.target.files[0];
        let reader = new FileReader();
        // params
        // keep tracks as is, split segments
        let splitSegOnly = document.querySelector("#splitSegOnly").checked;
        // split count
        let splitAt = document.querySelector("#splitAt").value;
        // keep common point
        let keepCommonPt = document.querySelector("#keepCommonPt").checked;
        // split track suffix
        let trkSuffix = document.querySelector("#trkSuffix").value;
        // split file name suffix
        let fileSuffix = document.querySelector("#fileSuffix").value;
        if (keepCommonPt) {
            splitAt--;
        }
        reader.readAsText(file);
        reader.onloadend = function (e) {
            let gpxSrcDoc = (new DOMParser()).parseFromString(e.target.result, "application/xml");
            const errorNode = gpxSrcDoc.querySelector("parsererror");
            if (errorNode) {
                alert("GPX malformed!" + errorNode)
            }
            let gpxSrc = gpxSrcDoc.getElementsByTagName("gpx");
            if (gpxSrc.length != 1) {
                alert("GPX malformed! Multiple gpx tags.");
            }

            let trkSrcNodes = gpxSrc[0].getElementsByTagName("trk");
            let trkDstNodes = []
            for (let trkNode of trkSrcNodes) {
                let trksegNodes = [];
                for (let trksegNode of trkNode.getElementsByTagName("trkseg")) {
                    let trkptNodes = trksegNode.getElementsByTagName("trkpt");
                    for (let i = 0; i < trkptNodes.length / splitAt; i++) {
                        console.log(i)
                        let tmpTrksegNode = trksegNode.cloneNode(true);
                        let tmpTrkptNodes = tmpTrksegNode.getElementsByTagName("trkpt");
                        const ptCnt = tmpTrkptNodes.length;
                        for (let tbr = 0; tbr < ptCnt; tbr++) {
                            tmpTrkptNodes[0].remove();
                        }
                        let j = 0;
                        for (; j < splitAt && (i * splitAt) + j < trkptNodes.length; j++) {
                            tmpTrksegNode.appendChild(trkptNodes[(i * splitAt) + j].cloneNode(true))
                        }
                        // no need to add 1 since j is post-incremented
                        if (keepCommonPt && (i * splitAt) + j < trkptNodes.length) {
                            tmpTrksegNode.appendChild(trkptNodes[(i * splitAt) + j].cloneNode(true))
                        }
                        if (splitSegOnly) {
                            trksegNodes.push(tmpTrksegNode)
                        } else {
                            let tmpTrkDstNode = trkNode.cloneNode(true);
                            for (let tbr of tmpTrkDstNode.getElementsByTagName("trkseg")) {
                                tbr.remove();
                            }
                            tmpTrkDstNode.getElementsByTagName("name")[0].textContent += trkSuffix + i;
                            tmpTrkDstNode.getElementsByTagName("desc")[0].textContent += trkSuffix + i;
                            tmpTrkDstNode.appendChild(tmpTrksegNode);
                            trkDstNodes.push(tmpTrkDstNode)
                        }

                    }
                }
                if (splitSegOnly) {
                    let tmpTrksegNodes = trkNode.getElementsByTagName("trkseg")
                    const ptCnt = tmpTrksegNodes.length;
                    for (let tbr = 0; tbr < ptCnt; tbr++) {
                        tmpTrksegNodes[0].remove();
                    }
                    trksegNodes.forEach(trksegNode => {
                        trkNode.appendChild(trksegNode);
                    });
                }
            }

            if (!splitSegOnly) {
                const ptCnt = trkSrcNodes.length;
                for (let tbr = 0; tbr < ptCnt; tbr++) {
                    trkSrcNodes[0].remove()
                }
                trkDstNodes.forEach(trkDstNode => {
                    gpxSrc[0].appendChild(trkDstNode)
                });
            }

            const serializer = new XMLSerializer();
            clean(gpxSrc[0])
            const gpxStr = serializer.serializeToString(gpxSrc[0]);
            let name = file.name.split('.');
            name.splice(-1, 0, fileSuffix)
            save(name.join("."), gpxStr)
        };
    }

    document.getElementById('file').addEventListener('change', handleFileSelect, false);
</script>

</html>